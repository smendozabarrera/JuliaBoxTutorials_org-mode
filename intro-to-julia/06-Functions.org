#+TITLE:         Functions in Julia
#+AUTHOR:        Juliabox team
#+DRAWERS:       sfmb
#+EMAIL:         s.f.m@ieee.org
#+DATE:          20/09/2018
#+DESCRIPTION:   Julia Language tutorials and testing
#+KEYWORDS:      julia, data science, emacs, ESS, org-mode, development
#+LANGUAGE:      en
#+OPTIONS:       H:10 num:t toc:nil \n:nil @:t ::t |:t ^:{} -:t f:t *:t <:t d:HIDDEN
#+OPTIONS:       TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+OPTIONS:       LaTeX:dvipng
#+INFOJS_OPT:    view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:
#+LINK_HOME:
#+XSLT:
#+STYLE: <link rel="stylesheet" type="text/css" href="dft.css"/>

#+LaTeX_CLASS: IEEEtran
#+LATEX_CLASS_OPTIONS: [letterpaper, 9pt, twoside, compsoc, final]
#+LATEX_HEADER: \usepackage[USenglish]{babel}
#+LATEX_HEADER: \hyphenation{do-cu-ment}
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \usepackage{makeidx}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage[ttdefault=true]{AnonymousPro}
#+LATEX_HEADER: \renewcommand*\familydefault{\ttdefault} %% Only if the base font of the document is to be typewriter style
#+LATEX_HEADER: \usepackage[libertine,bigdelims]{newtxmath}
#+LATEX_HEADER: \usepackage[cal=boondoxo,bb=boondox,frak=boondox]{mathalfa}
#+LATEX_HEADER: \useosf % change normal text to use proportional oldstyle figures

#+LATEX_HEADER: \markboth{Functions in Julia}%
#+LATEX_HEADER: {Bizland HUB}
#+LATEX_HEADER: \newcommand{\degC}{$^\circ$C{}}

#+STYLE: <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script>

# -*- mode: org; -*-
#+OPTIONS:   toc:2
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>

#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>

#+BEGIN_ABSTRACT
Functions in Julia.

*Thu Sep 20 17:41:45 CDT 2018*
#+END_ABSTRACT

* Functions
  :PROPERTIES:
  :CUSTOM_ID: functions
  :END:

Topics:

1. How to declare a function
2. Duck-typing in Julia
3. Mutating vs. non-mutating functions
4. Some higher order functions

** How to declare a function
   :PROPERTIES:
   :CUSTOM_ID: how-to-declare-a-function
   :END:

Julia gives us a few different ways to write a function. The first
requires the =function= and =end= keywords

#+begin_src julia :session :results output :exports all
  function sayhi(name)
      println("Hi $name, it's great to see you!")
  end

  name = "Sergio";
  sayhi(name)
#+end_src

#+RESULTS:
: sayhi (generic function with 1 method)
:
:
: Hi Sergio, it's great to see you!

#+begin_src julia :session :results output :exports all
  function f(x)
      (x^2)
  end

  x = rand(10);
  map(f, x)

  x = Vector(1:10);
  map(f, x)
#+end_src

#+RESULTS:
#+begin_example
f (generic function with 1 method)


10-element Array{Float64,1}:
 0.5366609790129925
 0.344540678557947
 0.31843295442348457
 0.32754570451424053
 0.17016468393461176
 0.02187529474908247
 0.4911918680548554
 0.13283930335337862
 0.19558972388688842
 0.844909037682892


10-element Array{Int64,1}:
   1
   4
   9
  16
  25
  36
  49
  64
  81
 100
#+end_example

We can call either of these functions like this:

#+begin_src julia :session :results output :exports all
  sayhi("C-3PO")
#+end_src

#+RESULTS:
: Hi C-3PO, it's great to see you!

#+begin_src julia :session :results output :exports all
  f(42)
#+end_src

#+RESULTS:
: 1764

Alternatively, we could have declared either of these functions in a
single line

#+begin_src julia :session :results output :exports all
  sayhi2(name) = println("Hi $name, it's great to see you!")
#+end_src

#+RESULTS:
: sayhi2 (generic function with 1 method)

#+begin_src julia :session :results output :exports all
  f2(x) = x^2
#+end_src

#+RESULTS:
: f2 (generic function with 1 method)

#+begin_src julia :session :results output :exports all
  sayhi2("R2D2")
#+end_src

#+RESULTS:
: Hi R2D2, it's great to see you!

#+begin_src julia :session :results output :exports all
  f2(42)
#+end_src

#+RESULTS:
: 1764

Finally, we could have declared these as "anonymous" functions

#+begin_src julia :session :results output :exports all
  sayhi3 = name -> println("Hi $name, it's great to see you!")
#+end_src

#+RESULTS:
: #15 (generic function with 1 method)

#+begin_src julia :session :results output :exports all
  f3 = x -> x^2
#+end_src

#+RESULTS:
: #17 (generic function with 1 method)

#+begin_src julia :session :results output :exports all
  sayhi3("Chewbacca")
#+end_src

#+RESULTS:
: Hi Chewbacca, it's great to see you!

#+begin_src julia :session :results output :exports all
  f3(42)
#+end_src

#+RESULTS:
: 1764

** Duck-typing in Julia
   :PROPERTIES:
   :CUSTOM_ID: duck-typing-in-julia
   :END:

/"If it quacks like a duck, it's a duck."/ Julia functions will just
work on whatever inputs make sense. For example, =sayhi= works on the
name of this minor tv character, written as an integer...

#+begin_src julia :session :results output :exports all
  sayhi(55595472)
#+end_src

#+RESULTS:
: Hi 55595472, it's great to see you!

And =f= will work on a matrix.

#+begin_src julia :session :results output :exports all
  A = rand(3, 3)
  A
#+end_src

#+RESULTS:
: 3×3 Array{Float64,2}:
:  0.893785  0.239299  0.248672
:  0.524892  0.878067  0.771191
:  0.709431  0.83372   0.618918
: 3×3 Array{Float64,2}:
:  0.893785  0.239299  0.248672
:  0.524892  0.878067  0.771191
:  0.709431  0.83372   0.618918

#+begin_src julia :session :results output :exports all
  f(A)
#+end_src

#+RESULTS:
: 3×3 Array{Float64,2}:
:  1.10087  0.631326  0.560713
:  1.47714  1.53957   1.28499
:  1.51077  1.41783   1.20243

=f= will also work on a string like "hi" because =*= is defined for
string inputs as string concatenation.

#+begin_src julia :session :results output :exports all
  f("hi")
#+end_src

#+RESULTS:
: "hihi"

On the other hand, =f= will not work on a vector. Unlike =A^2=, which is
well-defined, the meaning of =v^2= for a vector, =v=, is ambiguous.

#+begin_src julia :session :results output :exports all
  v = rand(3)
#+end_src

#+RESULTS:
: 3-element Array{Float64,1}:
:  0.26949887384325555
:  0.890390713676924
:  0.4139908009026383

#+begin_src julia :session :results output :exports all
  f(v)
#+end_src

#+RESULTS:
#+begin_example
ERROR: MethodError: no method matching ^(::Array{Float64,1}, ::Int64)
Closest candidates are:
  ^(!Matched::Float16, ::Integer) at math.jl:782
  ^(!Matched::Missing, ::Integer) at missing.jl:120
  ^(!Matched::Missing, ::Number) at missing.jl:93
  ...
Stacktrace:
 [1] macro expansion at ./none:0 [inlined]
 [2] literal_pow at ./none:0 [inlined]
 [3] f(::Array{Float64,1}) at ./none:2
 [4] top-level scope at none:0
#+end_example

** Mutating vs. non-mutating functions
   :PROPERTIES:
   :CUSTOM_ID: mutating-vs.non-mutating-functions
   :END:

By convention, functions followed by =!= alter their contents and
functions lacking =!= do not.

For example, let's look at the difference between =sort= and =sort!=.

#+begin_src julia :session :results output :exports all
  v = [3, 5, 2]
#+end_src

#+RESULTS:
: 3-element Array{Int64,1}:
:  3
:  5
:  2

#+begin_src julia :session :results output :exports all
  sort(v)
#+end_src

#+RESULTS:
: 3-element Array{Int64,1}:
:  2
:  3
:  5

#+begin_src julia :session :results output :exports all
  v
#+end_src

#+RESULTS:
: 3-element Array{Int64,1}:
:  3
:  5
:  2

=sort(v)= returns a sorted array that contains the same elements as =v=,
but =v= is left unchanged.

On the other hand, when we run =sort!(v)=, the contents of v are sorted
within the array =v=.

#+begin_src julia :session :results output :exports all
  sort!(v)
#+end_src

#+RESULTS:
: 3-element Array{Int64,1}:
:  2
:  3
:  5

#+begin_src julia :session :results output :exports all
  v
#+end_src

#+RESULTS:
: 3-element Array{Int64,1}:
:  2
:  3
:  5

** Some higher order functions
   :PROPERTIES:
   :CUSTOM_ID: some-higher-order-functions
   :END:

*** map
    :PROPERTIES:
    :CUSTOM_ID: map
    :END:

=map= is a "higher-order" function in Julia that /takes a function/ as
one of its input arguments. =map= then applies that function to every
element of the data structure you pass it. For example, executing

#+begin_src julia :session :results output :exports all
  map(f, [1, 2, 3])
#+end_src

#+RESULTS:
: 3-element Array{Int64,1}:
:  1
:  4
:  9

will give you an output array where the function =f= has been applied to
all elements of =[1, 2, 3]=

#+begin_src julia :session :results output :exports all
  [f(1), f(2), f(3)]
#+end_src

#+RESULTS:
: 3-element Array{Int64,1}:
:  1
:  4
:  9

#+begin_src julia :session :results output :exports all
  map(f, [1, 2, 3])
#+end_src

#+RESULTS:
: 3-element Array{Int64,1}:
:  1
:  4
:  9

Here we've squared all the elements of the vector =[1, 2, 3]=, rather
than squaring the vector =[1, 2, 3]=.

To do this, we could have passed to =map= an anonymous function rather
than a named function, such as

#+begin_src julia :session :results output :exports all
  x -> x^3
#+end_src

#+RESULTS:
: #19 (generic function with 1 method)

via

#+begin_src julia :session :results output :exports all
  map(x -> x^3, [1, 2, 3])
#+end_src

#+RESULTS:
: 3-element Array{Int64,1}:
:   1
:   8
:  27

and now we've cubed all the elements of =[1, 2, 3]=!

*** broadcast
    :PROPERTIES:
    :CUSTOM_ID: broadcast
    :END:

=broadcast= is another higher-order function like =map=. =broadcast= is
a generalization of =map=, so it can do every thing =map= can do and
more. The syntax for calling =broadcast= is the same as for calling
=map=

#+begin_src julia :session :results output :exports all
  broadcast(f, [1, 2, 3])
#+end_src

#+RESULTS:
: 3-element Array{Int64,1}:
:  1
:  4
:  9

and again, we've applied =f= (squared) to all the elements of
=[1, 2, 3]= - this time by "broadcasting" =f=!

Some syntactic sugar for calling =broadcast= is to place a =.= between
the name of the function you want to =broadcast= and its input
arguments. For example,

#+begin_src julia :session :results output :exports all
  broadcast(f, [1, 2, 3])
#+end_src

#+RESULTS:
: 3-element Array{Int64,1}:
:  1
:  4
:  9

is the same as

#+begin_src julia :session :results output :exports all
  f.([1, 2, 3])
#+end_src

#+RESULTS:
: 3-element Array{Int64,1}:
:  1
:  4
:  9

#+begin_src julia :session :results output :exports all
  f.([1, 2, 3])
#+end_src

#+RESULTS:
: 3-element Array{Int64,1}:
:  1
:  4
:  9

Notice again how different this is from calling

#+begin_src julia :session :results output :exports all
  f([1, 2, 3])
#+end_src

#+RESULTS:
#+begin_example
ERROR: MethodError: no method matching ^(::Array{Int64,1}, ::Int64)
Closest candidates are:
  ^(!Matched::Float16, ::Integer) at math.jl:782
  ^(!Matched::Missing, ::Integer) at missing.jl:120
  ^(!Matched::Missing, ::Number) at missing.jl:93
  ...
Stacktrace:
 [1] macro expansion at ./none:0 [inlined]
 [2] literal_pow at ./none:0 [inlined]
 [3] f(::Array{Int64,1}) at ./none:2
 [4] top-level scope at none:0
#+end_example

We can square every element of a vector, but we can't square a vector!

To drive home the point, let's look at the difference between

#+begin_src julia :session :results output :exports all
  f(A)
#+end_src

#+RESULTS:
: 3×3 Array{Float64,2}:
:  1.10087  0.631326  0.560713
:  1.47714  1.53957   1.28499
:  1.51077  1.41783   1.20243

and

#+begin_src julia :session :results output :exports all
  f.(A)
#+end_src

#+RESULTS:
: 3×3 Array{Float64,2}:
:  0.798852  0.057264  0.061838
:  0.275511  0.771002  0.594735
:  0.503292  0.695089  0.383059

for a matrix =A=:

#+begin_src julia :session :results output :exports all
  A = [(i + (3 * j)) for j in 0:2, i in 1:3]
#+end_src

#+RESULTS:
: 3×3 Array{Int64,2}:
:  1  2  3
:  4  5  6
:  7  8  9

#+begin_src julia :session :results output :exports all
  f(A)
#+end_src

#+RESULTS:
: 3×3 Array{Int64,2}:
:   30   36   42
:   66   81   96
:  102  126  150

As before we see that for a matrix, =A=,

#+begin_src julia :session :results output :exports all
  f(A) = A^2 = A * A
#+end_src

#+RESULTS:
: ERROR: syntax: "2" is not a valid function argument name

On the other hand,

#+begin_src julia :session :results output :exports all
  B = f.(A)
#+end_src

#+RESULTS:
: 3×3 Array{Int64,2}:
:   1   4   9
:  16  25  36
:  49  64  81

contains the squares of all the entries of =A=.

This dot syntax for broadcasting allows us to write relatively complex
compound elementwise expressions in a way that looks natural/closer to
mathematical notation. For example, we can write

#+begin_src julia :session :results output :exports all
  A .+ 2 .* f.(A) ./ A
#+end_src

#+RESULTS:
: 3×3 Array{Float64,2}:
:   3.0   6.0   9.0
:  12.0  15.0  18.0
:  21.0  24.0  27.0

instead of

#+begin_src julia :session :results output :exports all
  broadcast(x -> x + 2 * f(x) / x, A)
#+end_src

#+RESULTS:
: 3×3 Array{Float64,2}:
:   3.0   6.0   9.0
:  12.0  15.0  18.0
:  21.0  24.0  27.0

and this will still compile down to code that runs as efficiently as
=C=!

** Exercises
    :PROPERTIES:
    :CUSTOM_ID: exercises
    :END:

*** Exercise 1
     :PROPERTIES:
     :CUSTOM_ID: section
     :END:

Write a function that adds 1 to its input.

#+begin_src julia :session :results output :exports all
  function addOne(x)
      x + 1
  end
#+end_src

#+RESULTS:
: addOne (generic function with 1 method)

*** Exercise 2
     :PROPERTIES:
     :CUSTOM_ID: section-1
     :END:

Use =map= or =broadcast= to increment every element of matrix =A= by
=1=.

#+begin_src julia :session :results output :exports all
  broadcast(addOne, A)
#+end_src

#+RESULTS:
: 3×3 Array{Int64,2}:
:  2  3   4
:  5  6   7
:  8  9  10

*** Exercise 3
     :PROPERTIES:
     :CUSTOM_ID: section-2
     :END:

Use the broadcast dot syntax to increment every element of matrix =A= by
=1=.

#+begin_src julia :session :results output :exports all
  addOne.(A)
#+end_src

#+RESULTS:
: 3×3 Array{Int64,2}:
:  2  3   4
:  5  6   7
:  8  9  10

/EOF/
